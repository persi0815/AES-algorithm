# AES 알고리즘을 이용한 암호화 복호화 구현 & Avalanche 효과 분석

## AES 알고리즘

AES(Advanced Encryption Standard)는 `대칭 키 블록 암호화 알고리즘`으로, 128비트 블록 크기와 다양한 키 크기(128비트, 192비트, 256비트)를 지원한다. 
AES는 여러 라운드를 거쳐 암호화를 수행하며, 각 라운드에서 비트, 바이트, 열 등의 변환을 통해 입력 데이터가 점차 암호화된다.

### AES 알고리즘 이용해볼 수 있는 사이트

https://www.formaestudio.com/rijndaelinspector/

## 분석 결과

### 암호화, 복호화
암호키("2022126061" + "YANGJW"): `3230323231323630363159414E474A57`

평문("ABCDEFGHIJKLMNOP”): `4142434445464748494A4B4C4D4E4F50`

⇒ 암호화 결과: `4911697c41e0f2c065fc7300efafb990`

⇒ 복호화 결과: `4142434445464748494A4B4C4D4E4F50`

## Avalance Effect

**Avalanche Effect**는 암호화 알고리즘에서 중요한 특성으로, 입력의 작은 변화(예: 단일 비트 변경)가 출력에 큰 변화를 일으키는 현상이다. 즉, 입력의 아주 작은 차이가 암호문 전체에 큰 변화를 가져와야 한다는 개념이다.
→ 보안 측면에서 암호화의 강력함을 평가하는 데 중요한 요소로 여겨지고 있다.

AES 알고리즘에서 Avalanche Effect는 특히 잘 관찰된다. 평문의 작은 변경(ex: 1비트 차이)이 전체 암호문에 큰 영향을 미치는 이유는 AES의 내부 구조(대치, 행 이동, 열 혼합, 키 추가) 덕분이다. 각 라운드가 데이터를 복잡하게 변형하여 Avalanche Effect를 증폭시켜, 최종 암호문이 원래 평문과는 매우 다르게 나타난다.

- **SubBytes (대치)**
  AES의 첫 번째 단계는 SubBytes로, 바이트 단위로 S-box에서 대체 변환을 수행
- **ShiftRows (행 이동)**
  ShiftRows는 AES 블록 내 행들을 순환 이동하여 데이터를 더 복잡하게 섞음
- **MixColumns (열 혼합)**
  MixColumns는 열 단위로 선형 변환을 수행하여, 데이터를 한층 더 복잡하게 변환
- **AddRoundKey (라운드 키 추가)**
  각 라운드에서 키가 블록에 XOR 연산을 통해 추가

### Avalanche 효과_1

첫 번째 한 비트를 바꾼 평문: `C142434445464748494A4B4C4D4E4F50`

바꾼 평문을 기존키를 통해 암호화한 결과: `9261bbf64e41f18cfa5b2c4e0cd0ce92`

기존의 암호화 결과: `4911697c41e0f2c065fc7300efafb990`

⇒ 두 결과는 `‘68’ 비트` 차이

### Avalanche 효과_2

첫 번째 비트 바꾼 암호키: `B2303231323630363159414E474A57`

바꾼 암호키로 암호화한 결과: `8d24cf4c10051794448f6fe34a8babd5`

기존 암호키로 암호화한 결과:  `4911697c41e0f2c065fc7300efafb990`

⇒ 두 결과는 `‘55’ 비트` 차이

### 느낀 점
평문에서 첫 번째 한 비트만 바꾸어 암호화했을 뿐인데, 해당 결과와 기존의 결과의 차이가 ‘68’비트나 났고, 암호키 첫번째 비트만 바꾸어 암호화한 결과와 기존의 결과 또한 ‘55’ 비트나 차이가 났다. 평문과 암호키가 모두 128 비트밖에 되지 않았는데, 평문이나 암호키 한 비트의 차이가 결과에 이토록 큰 차이를 낸다는 점이 놀라웠다. 

## main 함수 흐름
1. AES 키 생성: 학번과 이름을 기반으로 AES 키를 생성
2. 평문 암호화: 생성된 AES 키와 고정된 IV를 사용해 평문을 암호화
3. 복호화 및 확인: 암호문을 복호화하여 평문과 동일한지 확인
4. 평문 변경 후 암호화: 평문의 첫 번째 비트를 변경한 후 다시 암호화
5. 키 변경 후 암호화: AES 키의 첫 번째 비트를 변경한 후, 원래의 평문을 암호화
6. 비트 차이 계산: 원본 암호문과 변경된 평문 암호문의 비트 차이 & 원본 암호문과 변경된 키 암호문의 비트 차이를 계산

## 코드 흐름
1. 키 생성 (generateKey)

    학번(10자)과 이름(6자)을 사용하여 총 16자(128비트)인 AES 암호화 키를 생성한다.

2. 이진 문자열 변환 (stringToBinary)

   각 문자는 ASCII 값을 기준으로 8비트 이진수로 변환되며, 출력 문자열의 길이는 8의 배수가 된다.

3. AES 암호화 (aesEncrypt)

   AES 암호화는 AES/CBC/NoPadding 모드를 사용하여 수행되며, 평문은 반드시 128비트(16바이트) 길이로 고정한다. 

4. AES 복호화 (aesDecrypt)

   AES 복호화는 암호화와 대칭적으로 동작하며, 암호화된 데이터를 복호화한다.

5. 고정된 IV 생성 (generateFixedIv)

   암호화 및 복호화 과정에서 일관성을 유지하기 위해 고정된 초기화 벡터(IV)를 사용한다. 이 IV는 16바이트 크기의 0으로 채워진 배열로 생성된다.

6. 첫 번째 비트 변경 (flipFirstBitInPlaintext, flipFirstBitInKey)

    평문이나 AES 키의 첫 번째 비트를 변경한다. XOR 연산을 사용하여 첫 번째 바이트의 최상위 비트(MSB)를 뒤집어 입력값을 최소한으로 변경한다. 평문의 경우, 첫 번째 바이트의 첫 번째 비트를 변경하고, 키의 경우, AES 키의 첫 번째 비트를 변경한다. 
   
7. 16진수 변환 (bytesToHex)

   바이트 배열을 16진수 문자열로 변환하여 더 쉽게 읽을 수 있게 한다.

8. 바이트 배열을 이진 문자열로 변환 (byteArrayToBinaryString)

   암호문을 128비트 이진 문자열로 변환하여, 암호문 간의 정확한 비트 차이를 확인하는 데 사용한다.

9. 비트 차이 계산 (calculateBitDifferenceFromBinaryStrings)

   두 개의 128비트 이진 문자열을 비교하여 서로 다른 비트의 개수를 계산한다. 각 문자열의 문자를 하나씩 비교하여 다른 위치에서의 비트 차이를 계산하고, 이를 통해 Avalanche 효과를 확인할 수 있다.